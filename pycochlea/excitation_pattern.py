# Autogenerated with SMOP version 0.25
# /usr/local/bin/smop CalcLoudnessFunctions.m -o CalcLoudnessFunctions.py
from __future__ import division
import numpy as np

import pylab

def RoundedExponential_(f_center,f0,I_dB):
    min_level_db=20
    fk=f_center / 1000
    I_dB=max(min_level_db,I_dB)
    erb=24.7 * (4.37 * fk + 1)
    erbk=24.7 * (4.37 * 1 + 1)
    pk51=(4 * 1000) / erbk
    p51=4 * f_center / erb
    pl=p51 - 0.35 * (I_dB - 51) * (p51 / pk51)
    pu=p51
    pl=pl.clip(0,max(pl))
    pu=pu.clip(0,max(pu))
    g=(f0 - f_center) / f_center
    ipos=pylab.find(g >= 0)
    ineg=pylab.find(g < 0)
    w=np.zeros(g.shape)
    w[ipos]=(1 + pu[ipos]*g[ipos])*(np.exp(- pu[ipos]*g[ipos]))
    w[ineg]=(1 - pl[ineg]*g[ineg])*(np.exp(+ pl[ineg]*g[ineg]))
    return w

def MiddleEarFilter_(f0,I_in):
    flt=np.array([[  2.00000000e+01,   3.91500000e+01],
       [  2.50000000e+01,   3.14000000e+01],
       [  3.15000000e+01,   2.54000000e+01],
       [  4.00000000e+01,   2.09000000e+01],
       [  5.00000000e+01,   1.80000000e+01],
       [  6.30000000e+01,   1.61000000e+01],
       [  8.00000000e+01,   1.42000000e+01],
       [  1.00000000e+02,   1.25000000e+01],
       [  1.25000000e+02,   1.11300000e+01],
       [  1.60000000e+02,   9.71000000e+00],
       [  2.00000000e+02,   8.42000000e+00],
       [  2.50000000e+02,   7.20000000e+00],
       [  3.15000000e+02,   6.10000000e+00],
       [  4.00000000e+02,   4.70000000e+00],
       [  5.00000000e+02,   3.70000000e+00],
       [  6.30000000e+02,   3.00000000e+00],
       [  7.50000000e+02,   2.70000000e+00],
       [  8.00000000e+02,   2.60000000e+00],
       [  1.00000000e+03,   2.60000000e+00],
       [  1.25000000e+03,   2.70000000e+00],
       [  1.50000000e+03,   3.70000000e+00],
       [  1.60000000e+03,   4.60000000e+00],
       [  2.00000000e+03,   8.50000000e+00],
       [  2.50000000e+03,   1.08000000e+01],
       [  3.00000000e+03,   7.30000000e+00],
       [  3.15000000e+03,   6.70000000e+00],
       [  4.00000000e+03,   5.70000000e+00],
       [  5.00000000e+03,   5.70000000e+00],
       [  6.00000000e+03,   7.60000000e+00],
       [  6.30000000e+03,   8.40000000e+00],
       [  8.00000000e+03,   1.19000000e+01],
       [  9.00000000e+03,   1.06000000e+01],
       [  1.00000000e+04,   9.90000000e+00],
       [  1.12000000e+04,   1.19000000e+01],
       [  1.25000000e+04,   1.39000000e+01],
       [  1.40000000e+04,   1.60000000e+01],
       [  1.50000000e+04,   1.73000000e+01],
       [  1.60000000e+04,   1.78000000e+01]])
    a=np.interp(f0,flt[:,0],flt[:,1])
    I_out=I_in / (10.0 ** (a / 10))
    return I_out

def InternalExcitation_(f0):
    ie=np.array([[  8.00000000e+00,   2.62000000e+01],
       [  5.20000000e+01,   2.62000000e+01],
       [  7.40000000e+01,   2.02000000e+01],
       [  1.08000000e+02,   1.45000000e+01],
       [  1.40000000e+02,   1.20000000e+01],
       [  2.53000000e+02,   6.30000000e+00],
       [  5.00000000e+02,   3.60000000e+00],
       [  2.00000000e+04,   3.60000000e+00]])
    E_thr_Q=np.interp(f0,ie[:,0],ie[:,1])
    return E_thr_Q.flatten()

def ExcitationToSpecificLoudness_(E,f0):
    I_ref=1e-12
    E_thr_ref_dB=3.6
    C=0.0467338323243
    E_thr_Q_dB=InternalExcitation_(f0)
    G_dB=- (E_thr_Q_dB - E_thr_ref_dB)
    G=10.0 ** (G_dB / 10)
    alpha,A=AlphaAFromG_dB_(G_dB)
    E_s= E / I_ref
    specificLoudness=C * (( G * E_s + A) ** alpha - A ** alpha)
    E_thr_Q=np.zeros(E_thr_Q_dB.shape)
    for k in np.arange(len(f0)):
        E_thr_Q[k]=10 ** (E_thr_Q_dB[k] / 10)
        if (E_s[0,k] < E_thr_Q[k]).all():
            specificLoudness[0,k]=specificLoudness[0,k] * (2 * E_s[k] / (E_s[k] + E_thr_Q[k])) ** 1.5
        if (E_s[0,k] > 10 ** 10).all():
            specificLoudness[k]=C * (E_s[k] / 1040000.0) ** 0.5
    return specificLoudness

def AlphaAFromG_dB_(G_dB):
    alphaA=np.array([[-25.   ,   0.267,   8.8  ],
       [-20.   ,   0.252,   7.6  ],
       [-15.   ,   0.238,   6.6  ],
       [-10.   ,   0.222,   5.8  ],
       [ -5.   ,   0.21 ,   5.1  ],
       [  0.   ,   0.2  ,   4.62 ]])
    alpha=np.interp(G_dB,alphaA[:,0],alphaA[:,1])
    A=np.interp(G_dB,alphaA[:,0],alphaA[:,2])
    return alpha,A
    
def OuterEarFilter_(f0,I_in):
    flt = np.array([[  2.00000000e+01,   0.00000000e+00],
       [  2.50000000e+01,   0.00000000e+00],
       [  3.15000000e+01,   0.00000000e+00],
       [  4.00000000e+01,   0.00000000e+00],
       [  5.00000000e+01,   0.00000000e+00],
       [  6.30000000e+01,   0.00000000e+00],
       [  8.00000000e+01,   0.00000000e+00],
       [  1.00000000e+02,   0.00000000e+00],
       [  1.25000000e+02,   1.00000000e-01],
       [  1.60000000e+02,   3.00000000e-01],
       [  2.00000000e+02,   5.00000000e-01],
       [  2.50000000e+02,   9.00000000e-01],
       [  3.15000000e+02,   1.40000000e+00],
       [  4.00000000e+02,   1.60000000e+00],
       [  5.00000000e+02,   1.70000000e+00],
       [  6.30000000e+02,   2.50000000e+00],
       [  7.50000000e+02,   2.70000000e+00],
       [  8.00000000e+02,   2.60000000e+00],
       [  1.00000000e+03,   2.60000000e+00],
       [  1.25000000e+03,   3.20000000e+00],
       [  1.50000000e+03,   5.20000000e+00],
       [  1.60000000e+03,   6.60000000e+00],
       [  2.00000000e+03,   1.20000000e+01],
       [  2.50000000e+03,   1.68000000e+01],
       [  3.00000000e+03,   1.53000000e+01],
       [  3.15000000e+03,   1.52000000e+01],
       [  4.00000000e+03,   1.42000000e+01],
       [  5.00000000e+03,   1.07000000e+01],
       [  6.00000000e+03,   7.10000000e+00],
       [  6.30000000e+03,   6.40000000e+00],
       [  8.00000000e+03,   1.80000000e+00],
       [  9.00000000e+03,  -1.00000000e+00],
       [  1.00000000e+04,  -1.60000000e+00],
       [  1.12000000e+04,   1.90000000e+00],
       [  1.25000000e+04,   4.90000000e+00],
       [  1.40000000e+04,   2.00000000e+00],
       [  1.50000000e+04,  -2.00000000e+00],
       [  1.60000000e+04,   2.50000000e+00]])
    I_dB=np.interp(f0,flt[:,0],flt[:,1])
    I_out=I_in*(10.0 ** (I_dB / 10))
    return I_out

def excitation_pattern(f0,I,z=None,freqs=None,I_scale = 'dB',freeField=False,middleEar = True,binaural=False):
    """    
    Calculates the excitation pattern from a list of frecuencies and intensities
    
    freqs = np.logspace(log10(fmin),log(fmax),100)
    
    freqs,ep = excitation_pattern(f0, I_dB, freqs=freqs)
    
    Alternative on erbscale z
        
    dz = 0.1
    
    z = np.arange(1.8,39,dz)
    
    fErb,ep = excitation_pattern(f0, I_dB, z=z)
    """
    
    if type(f0) is not np.ndarray: f0 = np.array(f0,ndmin=1)
        
    if type(I) is not np.ndarray: I = np.array(I,ndmin=1)
    
    I_ref = 1.0e-12

    if I_scale=='dB':
        I_db = I
        I_lin = I_ref * 10**(I_db/10)        
    else:
        I_lin = I        
        
   
    f0 = list(f0)

   

    min_spl_dB=- 500
    min_spl=I_ref * 10 ** (min_spl_dB / 10)
    
    if freeField:
        I_lin = OuterEarFilter_(f0,I_lin)

    if middleEar:
        I_lin = MiddleEarFilter_(f0,I_lin)
    
    I_lin = I_lin.clip(min_spl,np.max(I_lin))
    
    I_db = 10 * np.log10(I_lin / I_ref)
    
    if z!=None:    
        #erbscale z to hertz
        freqs=(10.0 ** (z / 21.4) - 1) * 1000 / 4.37
            
    E=np.zeros(len(freqs))
    
    for ff, IIdb, II in zip(f0,I_db, I_lin ):
        
        w = RoundedExponential_(freqs , ff, IIdb)
        E = E + w * II
        
    ep=10 * np.log10(E / I_ref)
#    specificLoudness=ExcitationToSpecificLoudness_(E,fErb)
#    if binaural:
#        specificLoudness=2 * specificLoudness
#    return fErb,excitationPattern,specificLoudness
    return freqs,ep
